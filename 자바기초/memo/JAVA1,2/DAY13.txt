인터페이스를 사용하는 이유
1.여러 클래스에서 선언할 맴버들을 일관되게 하기 위해 사용한다.(표준화)
2.관계없는 클래스들을 그룹화 시킬 수 있다.(마커 인터페이스)

인터페이스의 불편함
	인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부만 재정의하여 사용하는게 불가능하다.
	이를 해결하기 위해 Adapter라는 추상클래스를 활용한다.
	
어댑터 클래스(추상 클래스)와 인터페이스
	인터페이스의 강제성을 완화시키기 위해 Adapter클래스를 사용한다.
	어댑터 클래스는 추상클래스로 만들기 때문에 미구현된 메소드와 구현된 메소드가 동시에 존재할 수 있다.
	그러므로 어댑터 클래스에서 인터페이스를 상속받아 강제성을 없애고 싶은 메소드만 재정의 해준다.
	이후 어댑터 클래스를 상속 받는 자식 클래스는 내가 원하는 메소드만 재정의할 수 있게 된다.
	이 때 어댑터 클래스의 이름은 이름뒤에 Adapter를 붙여주어 목적을 알려주는게 좋다.
	
인터페이스 ------------->추상클래스-------------->클래스
(모든 강제성)                 (일부 구현)               (전부 구현)

다중 상속
	여러 부모 클래스를 상속하는 것을 다중 상속이라고 한다.
	JAVA는 모호성 때문에 다중 상속을 지원하지 않는다.
	
	하지만 JDK8버전부터는 인터페이스에 default 메소드 등을 만드는것을 허용한다(특정 메소드의 구현을 허용한다.)
	여러 개를 구현(상속)할 수 있는 인터페이스 특징 때문에 다중상속을 지원하는 것이나 다름이 없다.

인터페이스의 추가된 기능(JDK1.8 부터 추가됨)
	1.default 메소드를 선언할 수 있다.
	[public] default 리턴타입 메소드명(매개변수){
			실행할 코드;
	}
	
	2.static 메소드를 선언할 수 있다.
	[public] static 리턴타입 메소드명(매개변수){
		실행할 코드;
	}

	3.private 메소드(jdk 9부터 사용 가능)


모호성 해결 방법 예시
	1. 두 개의 인터페이스에 같은 메소드가(이름,매개변수,리턴타입) 선언되어 있는 경우
	->자식 클래스에서 재정의하여 사용한다.
	(인터페이스명.super.메소드명으로 각 인터페이스의 메소드로 재정의 가능)

	2.부모 클래스의 메소드와 인터페이스의 디폴트 메소드가 같을 때
	->부모 클래스의 메소드가 사용된다.


마커 인터페이스(Marker Interface)
	클래스들을 그룹화하기 위한 목적으로 사용한다.
	서로 다른 클래스들을 공통되는 타입을 갖도록 하는 것이 유일한 목적이기 때문에 마커 인터페이스는 어떠한 맴버도 선언하지 않는다.

내부 클래스
	클래스 내부에 선언된 클래스를 '내부 클래스'라고 한다.
	내부 클래스를 가진 클래스를 '외부 클래스'라고 한다.
	
	클래스를 구성하는 맴버로 변수, 메소드, 생성자 뿐만 아니라 클래스도 가질 수 있다.
	만약 B클래스를 A클래스에서만 사용한다면 B클래스를 내부클래스로 만들어서 사용한다.
	외부 클래스가 메모리에 할당되야 내부 클래스의 객체화가 가능하기 때문에 B를 별도로 사용하지 못한다.
	내부 클래스는 외부 클래스의 맴버이기 때문에 외부 클래스의 맴버를 상속없이 쓸 수 있다.

내부 클래스의 종류
	1.인스턴스 내부 클래스
	2.스태틱 내부 클래스
	3.로컬 내부 클래스

익명 클래스(Anonymous class)
	-이름이 없는 클래스이다.
	-미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해 사용

