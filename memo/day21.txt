스태틱 블록 : 최초 1회 한번만 실행
                : Long 타입이라 처음 초기화때 null값이 들어감 -> null값에 ++해주는 코드를 만나 익셉션 발생을 막아주기위해서

static {
	sequence =0L;
}

Long sequence 선언 -> producId값 을 중복없이 1씩 증가해주기위해서

초기화 블록 : 생성자를 호출할 때 마다 실행 
{
	sequence++;
}	


JSONObject 생성자로 객체 넘겨주면 키값이 필드의 변수명, 밸류값이 생성한 객체의 값으로 생성.

프로그램 : 실행이 안된 상태.

프로세스 : 실행된 프로그램

쓰레드 : 프로세스 내의 작업 처리 경로

	-단일 쓰레드
		처리 경로를 한 개만 가지고 있기 때문에 직렬적이다.
		한번에 하나씩 처리하기 때문에 상대적으로 비효율적이다.
		하지만 하나의 작업에 문제가 발생하더라도 다른 작업은 시작하지 않았기 때문에
		다른 작업에는 문제가 발생하지 않는다. 따라서 안정성이 보장되고 설계 시 
		멀티 쓰레드에 비해 쉽다.

	-멀티 쓰레드
		하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로 분할해서 차례로 처리한다.
		여러 개의 처리 경로를 가질 수 있도록 하며, 동시 작업이 가능해진다.
		설계하기 굉장히 어려움, 하나의 쓰레드 문제 발생 시 모든 쓰레드에 문제가 발생하게 된다.
		멀티 쓰레드로 설계했다면, 처리량 증가, 효율성 증가, 처리비용 감소의 장점이 있기 때문에 단점을 감수하고 설계하는 편이다.

	
		
===========================================================================
멀티 쓰레드 구현 방법
	핵심 : run()메소드 재정의
	1.Thread  클래스
	2.Runnable 인터페이스 지정
	===========================================================================
	
	Thread 타입만 Thread생성 가능
	
	start() -> 스케쥴링 메소드 단일쓰레드를 멀티쓰레드로 만들어줌. 스케쥴링과 동시에 run메소드 실행

	join을 사용한 쓰레드가 끝나고 나서 나머지 쓰레드가 실행된다.
	단, 이미 join()전에 start()된 쓰레드는 멈출 수 없다.

	mutex : 자원을 구현한 객체 (자원의 주인)
 	
	자원의 공유 문제 발생 시 동기화를 사용하여 멀티 환경에서 특정 부분을 단일 환경으로 바꿔줘야 한다.
	
	쓰레드가 종료되려면 반드시 멈춰있어야한다. -> Interrupted 익셉션을 쓰레드를 멈추는 코드에서 항상 발생시켜 종료될 수 있게 한다.

	


