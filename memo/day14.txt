
예외 처리
	컴파일 시, 빌드 시, 런타임 시 오류가 발생하면 여러가지 오류가 발생한다.
	보통 오류가 발생하지 않도록 제어문을 사용하지만, 제어문을 사용할 수 없을 경우 예외 처리 문법을 사용한다.
	
	프러그램 실행 과정

	컴파일 -> .java ->.class
	빌드 ->  메모리할당 , .exe 만듬 
	링크 -> 경로 알아서 찾아줌
 	실행 

	실행중 사용자의 입력 

예외 처리 문법
	try{
	
	}catch(){
	
	} ... 

	}finally{

	}

*****************************************************
try -> 예외발생 -> 바로 catch()문에 잡을 객체가 있나 확인 있으면 그 catch문 실행 -> finally실행 -> 종료

오류가 발생 -> 발생한 오류의 객체가 메모리에 할당 -> 그 주소값을 담을 곳이 없으면 강제종료 (객체명 에서 받지 못하면 강제종료)
	->객체의 주소값이 담아놓을 변수가 없으면 gc가 예외 객체를 메모리에서 해제하려고하면 강제종료

catch문 -> 만약 객체변수명이 null이라면 다음 캐치문 실행 , 객체 변수명이 null이 아니라면 예외 주소값을 받은 상태이기 때문에 ->그 캐치문 실행

finally -> try문에서 외부장치와 통신한 드라이버,서버를 열었다면 반드시 그 try,catch문에서 닫아줘야 하므로 사용한다.

Exception으로 처리해주면 모든 예외가 잡히므로 finally를 쓰지 않아도 밑에 코드를 작성해도 괜찮지만 관례상 무조건 실행해야하는 코드는
finally안에 작성 (같은 몸통안에서 해결해주려는 느낌) + 가독성이 올라감

외부 장치와 os를 통신할때 열어주는 길 ->드라이버
java프로그램과 다른 프로그램을 통신할 때 열어주는 길 -> 드라이버

드라이버 열어주면 메모리를 차지하게된다. ->열어주고 닫아주지 않으면 메모리에 계속 누적이되어 해제되지못하고 터질 수 있다.




Exception은 컴파일러가 확인 가능한 클래스(컴파일 오류) -> throw 시 반드시 try-catch문으로 강종을 막아야 한다. ->강제종료 불가능
RuntimeException 은 컴파일러가 확인 불가능하게 재정의 해놓음(빌드 또는 런타임 오류) ->throw 시 try-catch문을 안해도 실행가능 -> 강제종료

throw 는 Exception 타입앞에 객체 앞에서만 사용할 수 있는 키워드
throw 는 강제로 Exception 타입의 객체를 메모리에 올려 예외를 발생시킨다. 



 