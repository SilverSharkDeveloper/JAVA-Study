상속(inheritance)
	1.기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때
	2. 여러 클래스 선언 시 필드가 겹칠 때 부모 클래스를 먼저 선언하고 공통 필드를 묶어서 자식 클래스들에게 상속해준다.

상속 문법
	class A{
		A필드
	}
	class B extends A{
		B필드
	}
	
super(): 부모 생성자
	자식 클래스 타입의 객체로 부모 필드에 접근할 수 있다.
	하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당한다고 생각할 수 있다.
	사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에 자식 생성자 호출 시 부모와 자식 필드 모두 메모리에 할당된다.
	이 때 부모 생성자를 호출하는 방법은 super()를 사용하는것
	만약, super()를 작성하지 않더라도 컴파일러가 자동으로 작성해준다.

다형성(polymorphism)
	1.오버로딩
	2.오버라이딩(재정의)
		부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의를 해야 한다.
		이는 자식에서 부모 필드의 메소드와 동일한 이름으로 선언하는 것이다.
		부모 필드가 메모리에 먼저 할당되고 a라는 메소드가 먼저 올라간다고 하면,
		자식 필드가 메모리에 할당되면서 재정의한 a메소드가 새롭게 만들어지는 것이 아니라
		기존에 할당된 a메소드 저장공간에 새롭게 재정의한 자식 필드의 소스코드 주소가 들어가게 된다.
		따라서 자식 객체로 a메소드에 접근하면 자식 필드에서 재정의한 소스코드의 내용이 읽히게 된다.

==================================================================================
접근 권한 제어자(접근자)
	default :다른 패키지에서 접근 불가
	public : 모든 곳에서 접근 가능
	protected : 다른 패키지에서 접근 불가
	private : 다른 클래스에서 접근 불가 

private -> getter setter 메소드를 이용한 접근 -> 화면단에선 필드에 직접접근이 불가 반드시 메소드를 통해 데이터를 통신해야하므로 private로 선언해 메소드
	만들라고 선언해주는 것

메소드는 메소드 내부의 작성한 코드를 담고있는 저장공간의 주소값을 가지는 저장공간이다.
메소드가 return값을 가지면 주소값이 리턴값으로 바뀐다
void 이면 리턴값이 없다.

자식객체에서 부모메소드를 오버라이딩하면 자식 객체에 오버라이딩한 메소드가 생기는 것이 아니라
부모 객체에 메소드가 가지는 주소값이 덮어씌워지는 것이다.

